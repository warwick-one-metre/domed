#!/usr/bin/env python3.6
#
# This file is part of domed.
#
# domed is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# domed is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with domed.  If not, see <http://www.gnu.org/licenses/>.

"""Dome daemon for the Warwick one-metre telescope"""

# pylint: disable=too-many-instance-attributes
# pylint: disable=too-many-branches
# pylint: disable=too-many-statements
# pylint: disable=too-many-return-statements
# pylint: disable=broad-except
# pylint: disable=invalid-name

import argparse
import datetime
import threading
import time
import Pyro4
import serial
from warwick.observatory.common import (
    daemons,
    log,
    IP,
    TryLock)
from warwick.observatory.common.helpers import pyro_client_matches

from warwick.observatory.dome import (
    DomeConfig,
    CommandStatus,
    DomeShutterStatus,
    DomeHeartbeatStatus)

DOME_CONFIG = {
    'onemetre': DomeConfig('onemetre_dome',
                           daemons.onemetre_dome,
                           [IP.OneMetreDome, IP.OneMetreTCS],
                           serial_port='/dev/dome',
                           heartbeat_port='/dev/dome-monitor'),
    'rasa': DomeConfig('rasa_dome',
                       daemons.rasa_dome,
                       [IP.RASAMain],
                       shutter_timeout_seconds=40,
                       command_delay_seconds=0.25,
                       step_command_delay_seconds=2,
                       has_bumper_guard=True,
                       # Open part way using steps to avoid belt slackening
                       # then open the rest of the way normally
                       slow_open_steps=5,
                       serial_port='/dev/dome',
                       heartbeat_port='/dev/dome-monitor'),
    'nites': DomeConfig('nites_dome',
                        daemons.nites_dome,
                        [IP.NitesMain],
                        serial_port='COM8',
                        serial_timeout_seconds=0.5,
                        shutter_timeout_seconds=10.5,
                        legacy_controller=True,
                        heartbeat_port='COM9')
}


class DomeDaemon:
    """Daemon class that wraps the RS232 interface"""
    def __init__(self, config):
        self._config = config
        self._port = None
        self._port_error = False

        self._status_lock = threading.Lock()
        self._status_time = None
        self._east_shutter = DomeShutterStatus.Closed
        self._west_shutter = DomeShutterStatus.Closed

        self._command_lock = threading.Lock()
        self._force_stopped = False
        self._engineering_mode = False

        runloop = threading.Thread(target=self.__monitor_dome_status)
        runloop.daemon = True
        runloop.start()

        self._heartbeat_port = None
        self._heartbeat_status = DomeHeartbeatStatus.Unavailable
        self._heartbeat_time_remaining = 0
        self._heartbeat_date = datetime.datetime.utcnow()
        self._heartbeat_siren_enabled = True

        if self._config.heartbeat_port:
            heartbeat = threading.Thread(target=self.__monitor_heartbeat)
            heartbeat.daemon = True
            heartbeat.start()

    def __monitor_dome_status(self):
        """Monitors the status of the dome by reading serial port"""
        while True:
            # Initial setup
            try:
                self._port = serial.Serial(self._config.serial_port,
                                           self._config.serial_baud,
                                           timeout=self._config.serial_timeout_seconds)
                prefix = 'Restored' if self._port_error else 'Established'
                log.info(self._config.log_name, prefix + ' serial connection to dome')
                self._port_error = False

            except Exception as exception:
                print(exception)
                print('Will retry in 5 seconds...')

                if not self._port_error:
                    log.error(self._config.log_name, 'Lost serial connection to dome')

                print('Failed to connect to serial port (' + str(exception) + ')')
                self._port_error = True
                time.sleep(5.)
                continue

            try:
                # Flush any stale state
                self._port.flushInput()
                self._port.flushOutput()

                if self._config.legacy_controller:
                    # The older non-PLC controllers will only return A/B/X/Y status bytes in
                    # response to an issued move command. We therefore need to try closing a
                    # step to find out where the shutters are now
                    step_once = lambda s: True
                    self.__move_shutter('A', step_once, self._config.command_delay_seconds, 0)
                    self.__move_shutter('B', step_once, self._config.command_delay_seconds, 0)

                # Main run loop
                while True:
                    data = self._port.read(1)

                    if not data:
                        if self._config.legacy_controller:
                            # Legacy controllers only send data in response to a move command
                            continue
                        else:
                            raise serial.SerialTimeoutException('Read timeout')

                    with self._status_lock:
                        self.__parse_status(data[0])
                        self._status_time = datetime.datetime.utcnow()

            except Exception as exception:
                self._port.close()

                print('Failed to read to serial port (' + str(exception) + ')')
                print('Will retry in 5 seconds...')
                if not self._port_error:
                    log.error(self._config.log_name, 'Lost serial connection to dome')

                self._port_error = True
                time.sleep(5.)

    def __parse_status(self, status):
        if status == ord('0'):
            self._east_shutter = DomeShutterStatus.Closed
            self._west_shutter = DomeShutterStatus.Closed
        elif status == ord('1'):
            self._east_shutter = DomeShutterStatus.Closed
            if self._west_shutter != DomeShutterStatus.Open:
                self._west_shutter = DomeShutterStatus.PartiallyOpen
        elif status == ord('2'):
            if self._east_shutter != DomeShutterStatus.Open:
                self._east_shutter = DomeShutterStatus.PartiallyOpen
            self._west_shutter = DomeShutterStatus.Closed
        elif status == ord('3'):
            if self._east_shutter != DomeShutterStatus.Open:
                self._east_shutter = DomeShutterStatus.PartiallyOpen
            if self._west_shutter != DomeShutterStatus.Open:
                self._west_shutter = DomeShutterStatus.PartiallyOpen
        elif status == ord('A'):
            if self._config.legacy_controller:
                self._east_shutter = DomeShutterStatus.PartiallyOpen
            else:
                self._east_shutter = DomeShutterStatus.Closing
        elif status == ord('a'):
            if self._config.legacy_controller:
                self._east_shutter = DomeShutterStatus.PartiallyOpen
            else:
                self._east_shutter = DomeShutterStatus.Opening
        elif status == ord('X'):
            self._east_shutter = DomeShutterStatus.Closed
        elif status == ord('x'):
            self._east_shutter = DomeShutterStatus.Open
        elif status == ord('B'):
            if self._config.legacy_controller:
                self._west_shutter = DomeShutterStatus.PartiallyOpen
            else:
                self._west_shutter = DomeShutterStatus.Closing
        elif status == ord('b'):
            if self._config.legacy_controller:
                self._west_shutter = DomeShutterStatus.PartiallyOpen
            else:
                self._west_shutter = DomeShutterStatus.Opening
        elif status == ord('Y'):
            self._west_shutter = DomeShutterStatus.Closed
        elif status == ord('y'):
            self._west_shutter = DomeShutterStatus.Open
        elif status == ord('R'):
            print('Bumper guard relay reset')
            log.error(self._config.log_name, 'Bumper guard relay reset')
        else:
            print('Unknown status code: {0}'.format(status))
            log.error(self._config.log_name, 'Unknown dome status code ' + str(status))

    def __monitor_heartbeat(self):
        """Monitors the heartbeat timer and close the dome if it expires"""
        first_connection = True
        while True:
            # Initial setup
            try:
                self._heartbeat_port = serial.Serial(self._config.heartbeat_port,
                                                     self._config.heartbeat_baud,
                                                     timeout=self._config.heartbeat_timeout_seconds)

                print('Connected to heartbeat monitor on', self._config.heartbeat_port)
                prefix = 'Established' if first_connection else 'Restored'
                log.info(self._config.log_name, prefix + ' USB connection to heartbeat monitor')
                first_connection = False
            except Exception as exception:
                print('Failed to open heartbeat monitor connection with error:')
                print(exception)
                print('Will retry in 5 seconds...')
                if self._heartbeat_status != DomeHeartbeatStatus.Unavailable:
                    log.error(self._config.log_name, 'Failed to connect to heartbeat monitor')
                time.sleep(5.)

                self._heartbeat_status = DomeHeartbeatStatus.Unavailable
                continue

            try:
                # Flush any stale state
                self._heartbeat_port.flushInput()
                self._heartbeat_port.flushOutput()
                self._heartbeat_status = DomeHeartbeatStatus.Disabled

                # Main run loop
                while True:
                    data = self._heartbeat_port.read(1)
                    if not data:
                        raise serial.SerialTimeoutException('Read timeout')

                    status = data[-1]
                    with self._status_lock:
                        self._heartbeat_time_remaining = 0
                        if status == 254:
                            if self._heartbeat_status != DomeHeartbeatStatus.TrippedClosing:
                                log.error(self._config.log_name,
                                          'Heartbeat monitor is closing dome')
                            self._heartbeat_status = DomeHeartbeatStatus.TrippedClosing
                            self._east_shutter = DomeShutterStatus.HeartbeatMonitorForceClosing
                            self._west_shutter = DomeShutterStatus.HeartbeatMonitorForceClosing
                            self._status_time = datetime.datetime.utcnow()
                        elif status == 255:
                            if self._heartbeat_status != DomeHeartbeatStatus.TrippedIdle:
                                log.info(self._config.log_name,
                                         'Heartbeat monitor has finished closing dome')
                            if self._heartbeat_status != DomeHeartbeatStatus.TrippedIdle \
                                    and self._config.legacy_controller:
                                # The heartbeat monitor disconnects the dome serial connection when
                                # it is closing the dome, so we don't know for sure what the current
                                # status of the dome is now. Issue another close step so that we can
                                # receive a new status update
                                step_once = lambda s: True
                                self.__move_shutter('A', step_once,
                                                    self._config.command_delay_seconds, 0)
                                self.__move_shutter('B', step_once,
                                                    self._config.command_delay_seconds, 0)
                            self._heartbeat_status = DomeHeartbeatStatus.TrippedIdle
                        elif status == 0:
                            if self._heartbeat_status != DomeHeartbeatStatus.Disabled:
                                log.info(self._config.log_name, 'Heartbeat disabled')
                            self._heartbeat_status = DomeHeartbeatStatus.Disabled
                        else:
                            if self._heartbeat_status != DomeHeartbeatStatus.Active:
                                log.info(self._config.log_name, 'Heartbeat enabled')
                            self._heartbeat_status = DomeHeartbeatStatus.Active

                            # Heartbeat monitor represents time using half-second ticks
                            self._heartbeat_time_remaining = status / 2.

                        self._heartbeat_date = datetime.datetime.utcnow()

            except Exception as exception:
                self._heartbeat_port.close()
                self._heartbeat_status = DomeHeartbeatStatus.Unavailable
                print(exception)
                print('Will retry in 5 seconds...')
                log.error(self._config.log_name, 'Failed to read heartbeat monitor')
                time.sleep(5.)

    def __move_shutter(self, command, at_requested_limit, step_delay, timeout, siren=True):
        """Issues a dome command and blocks until the final state is reached (or timeout)"""
        starttime = datetime.datetime.utcnow()
        step_count = 0

        if self._config.has_bumper_guard:
            try:
                length = self._port.write('R'.encode('ascii'))
                if length != 1:
                    raise serial.SerialException('Failed to send command R')
                time.sleep(step_delay)
            except Exception as exception:
                log.error(self._config.log_name, 'Failed to send serial command (' \
                          + str(exception) + ')')

        # Sound the siren for 5 seconds before any movement
        if siren and self._heartbeat_siren_enabled:
            try:
                length = self._heartbeat_port.write(bytes([0xFF]))
                if length != 1:
                    raise serial.SerialException('Failed to send heartbeat siren command')

                time.sleep(5.)
            except Exception as exception:
                log.error(self._config.log_name, 'Failed to send heartbeat serial command (' \
                          + str(exception) + ')')

        while True:
            try:
                length = self._port.write(command.encode('ascii'))
                if length != 1:
                    raise serial.SerialException('Failed to send command ' + command)
                step_count += 1
            except Exception as exception:
                log.error(self._config.log_name, 'Failed to send serial command (' \
                          + str(exception) + ')')
            time.sleep(step_delay)
            runtime = (datetime.datetime.utcnow() - starttime).total_seconds()
            heartbeat_tripped = self._heartbeat_status == DomeHeartbeatStatus.TrippedClosing or \
                self._heartbeat_status == DomeHeartbeatStatus.TrippedIdle
            at_limit = at_requested_limit(step_count)
            if self._force_stopped or heartbeat_tripped or at_limit or 0 < timeout < runtime:
                break

        return not self._force_stopped and not heartbeat_tripped and at_limit

    def __open_shutters(self, east, west, steps=0):
        """Open the requested shutters"""
        success = True

        # If moving a fixed number of steps then we must wait for the shutters
        # to stop moving between each step command to ensure the step size is constant
        step_delay = self._config.step_command_delay_seconds if steps > 0 \
            else self._config.command_delay_seconds

        # If moving a fixed number of steps then the timeout is implicit
        # (step_command_delay_seconds * steps)
        timeout = 0 if steps > 0 else self._config.shutter_timeout_seconds

        # TODO: Check the wind direction and open the downwind shutter first
        if east:
            # Open part way using steps
            if steps == 0 and self._config.slow_open_steps > 0:
                def at_east_step_limit(s):
                    return self._east_shutter == DomeShutterStatus.Open or s >= self._config.slow_open_steps

                slow_delay = self._config.step_command_delay_seconds
                success = success and self.__move_shutter('a', at_east_step_limit, slow_delay, 0)

            def at_east_requested_limit(s):
                return self._east_shutter == DomeShutterStatus.Open or 0 < steps <= s

            success = success and self.__move_shutter('a', at_east_requested_limit, step_delay,
                                                      timeout, self._config.slow_open_steps == 0)

        if west:
            # Open part way using steps
            if steps == 0 and self._config.slow_open_steps > 0:
                def at_west_step_limit(s):
                    return self._west_shutter == DomeShutterStatus.Open or s >= self._config.slow_open_steps

                slow_delay = self._config.step_command_delay_seconds
                success = success and self.__move_shutter('b', at_west_step_limit, slow_delay, 0)

            def at_west_requested_limit(s):
                return self._west_shutter == DomeShutterStatus.Open or 0 < steps <= s

            success = success and self.__move_shutter('b', at_west_requested_limit, step_delay,
                                                      timeout, self._config.slow_open_steps == 0)
        return success

    def __close_shutters(self, east, west, steps=0):
        """Close the requested shutters"""
        success = True

        # If moving a fixed number of steps then we must wait for the shutters
        # to stop moving between each step command to ensure the step size is constant
        step_delay = self._config.step_command_delay_seconds if steps > 0 \
            else self._config.command_delay_seconds

        # If moving a fixed number of steps then the timeout is implicit
        # (step_command_delay_seconds * steps)
        timeout = 0 if steps > 0 else self._config.shutter_timeout_seconds

        # TODO: Check the wind direction and close the upwind shutter first
        if west:
            def at_west_requested_limit(s):
                return self._west_shutter == DomeShutterStatus.Closed or 0 < steps <= s

            success = success and self.__move_shutter('B', at_west_requested_limit, step_delay, timeout)

        if east:
            def at_east_requested_limit(s):
                return self._east_shutter == DomeShutterStatus.Closed or 0 < steps <= s

            success = success and self.__move_shutter('A', at_east_requested_limit, step_delay, timeout)

        return success

    @Pyro4.expose
    def open_shutters(self, east=False, west=False, steps=0):
        """Opens the requested shutter.
           Returns once the requested shutters reach their limits or the command times out.
           If steps is greater than zero then open the defined number of steps with longer delay"""
        if not pyro_client_matches(self._config.control_ips):
            return CommandStatus.InvalidControlIP

        if self._engineering_mode:
            return CommandStatus.EngineeringModeActive

        if self._heartbeat_status == DomeHeartbeatStatus.TrippedClosing:
            return CommandStatus.HeartbeatCloseInProgress

        if self._heartbeat_status == DomeHeartbeatStatus.TrippedIdle:
            return CommandStatus.HeartbeatTimedOut

        with TryLock(self._command_lock) as success:
            if not success:
                return CommandStatus.Blocked

            if east and west:
                log.info(self._config.log_name, 'Opening both shutters')
            else:
                shutter = 'east' if east else 'west'
                log.info(self._config.log_name, 'Opening ' + shutter + ' shutter')

            if not self.__open_shutters(east, west, steps):
                log.error(self._config.log_name, 'Failed to open dome')
                return CommandStatus.Failed

            log.info(self._config.log_name, 'Open complete')
            return CommandStatus.Succeeded

    @Pyro4.expose
    def close_shutters(self, east=False, west=False, steps=0):
        """Closes the requested shutter.
           Returns once the requested shutters reach their limits or the command times out."""
        if self._engineering_mode:
            return CommandStatus.EngineeringModeActive

        if self._heartbeat_status == DomeHeartbeatStatus.TrippedClosing:
            return CommandStatus.HeartbeatCloseInProgress

        if self._heartbeat_status == DomeHeartbeatStatus.TrippedIdle:
            return CommandStatus.HeartbeatTimedOut

        with TryLock(self._command_lock) as success:
            if not success:
                return CommandStatus.Blocked

            if east and west:
                log.info(self._config.log_name, 'Closing both shutters')
            else:
                shutter = 'east' if east else 'west'
                log.info(self._config.log_name, 'Closing ' + shutter + ' shutter')

            if not self.__close_shutters(east, west, steps):
                log.error(self._config.log_name, 'Failed to close dome')
                return CommandStatus.Failed

            log.info(self._config.log_name, 'Close complete')
            return CommandStatus.Succeeded

    @Pyro4.expose
    def stop(self):
        """Stops any active shutter movement"""
        if not pyro_client_matches(self._config.control_ips):
            return CommandStatus.InvalidControlIP

        if self._heartbeat_status == DomeHeartbeatStatus.TrippedClosing:
            return CommandStatus.HeartbeatCloseInProgress

        log.warning(self._config.log_name, 'Received stop command')

        # The stop command overrides all other commands
        self._force_stopped = True
        with self._command_lock:
            self._force_stopped = False

        return CommandStatus.Succeeded

    @Pyro4.expose
    def set_engineering_mode(self, enabled):
        """Enable engineering mode (all movement commands disabled)"""
        if not pyro_client_matches(self._config.control_ips):
            return CommandStatus.InvalidControlIP

        with TryLock(self._command_lock) as success:
            if not success:
                return CommandStatus.Blocked

            if self._heartbeat_status == DomeHeartbeatStatus.TrippedClosing:
                return CommandStatus.HeartbeatCloseInProgress

            if self._heartbeat_status == DomeHeartbeatStatus.Active:
                return CommandStatus.EngineeringModeRequiresHeartbeatDisabled

            self._engineering_mode = enabled
            return CommandStatus.Succeeded

    @Pyro4.expose
    def set_heartbeat_timer(self, timeout):
        """Enable or disable the auto-close countdown"""
        if not pyro_client_matches(self._config.control_ips):
            return CommandStatus.InvalidControlIP

        if self._engineering_mode:
            return CommandStatus.EngineeringModeActive

        if self._heartbeat_status == DomeHeartbeatStatus.Unavailable:
            return CommandStatus.HeartbeatUnavailable

        if self._heartbeat_status == DomeHeartbeatStatus.TrippedClosing:
            return CommandStatus.HeartbeatCloseInProgress

        if timeout != 0 and self._heartbeat_status == DomeHeartbeatStatus.TrippedIdle:
            return CommandStatus.HeartbeatTimedOut

        if timeout < 0 or timeout >= 120:
            return CommandStatus.HeartbeatInvalidTimeout

        # Heartbeat monitor represents time using half-second ticks
        length = self._heartbeat_port.write(bytes([(2 * timeout)]))
        return CommandStatus.Succeeded if length == 1 else CommandStatus.Failed

    @Pyro4.expose
    def set_heartbeat_siren(self, enabled):
        """Enable or disable the siren before normal open/close
           (siren is always enabled for emergency close)
        """
        if not pyro_client_matches(self._config.control_ips):
            return CommandStatus.InvalidControlIP

        if self._engineering_mode:
            return CommandStatus.EngineeringModeActive

        self._heartbeat_siren_enabled = enabled
        return CommandStatus.Succeeded

    @Pyro4.expose
    def status(self):
        """Query the latest status."""
        with self._status_lock:
            date = self._status_time.strftime('%Y-%m-%dT%H:%M:%SZ')
            heartbeat_date = self._heartbeat_date.strftime('%Y-%m-%dT%H:%M:%SZ')
            closed = self._east_shutter == DomeShutterStatus.Closed and \
                self._west_shutter == DomeShutterStatus.Closed

            return {
                'date': date,
                'east_shutter': self._east_shutter,
                'west_shutter': self._west_shutter,
                'closed': closed,
                'engineering_mode': self._engineering_mode,
                'heartbeat_date': heartbeat_date,
                'heartbeat_status': self._heartbeat_status,
                'heartbeat_remaining': self._heartbeat_time_remaining,
                'heartbeat_siren': self._heartbeat_siren_enabled
            }


if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='Dome daemon')
    parser.add_argument('dome', choices=DOME_CONFIG.keys(), help='Telescope')
    args = parser.parse_args()
    dome = DOME_CONFIG[args.dome]
    dome.daemon.launch(DomeDaemon(dome))
